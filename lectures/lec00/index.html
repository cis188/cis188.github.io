<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>Course Intro, Python Basics | CIS 188: DevOps</title><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="all,follow"><meta name=googlebot content="index,follow,snippet,archive"><meta property="og:title" content="Course Intro, Python Basics"><meta property="og:description" content="Hello world! This is the first lecture.
Demos Poetry One reoccurring design pattern we see in DevOps is package managers. This is a tool that helps manage your program&rsquo;s dependencies. In other words, the package manager is in charge of keeping track of what packages your project needs to run correctly, and then downloading those packages in a way that makes it easy for your program to use this auxillary code."><meta property="og:type" content="article"><meta property="og:url" content="https://cis188.org/lectures/lec00/"><meta property="article:published_time" content="2020-12-01T00:00:00+00:00"><meta property="article:modified_time" content="2021-01-25T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Course Intro, Python Basics"><meta name=twitter:description content="Hello world! This is the first lecture.
Demos Poetry One reoccurring design pattern we see in DevOps is package managers. This is a tool that helps manage your program&rsquo;s dependencies. In other words, the package manager is in charge of keeping track of what packages your project needs to run correctly, and then downloading those packages in a way that makes it easy for your program to use this auxillary code."><link rel=stylesheet href=https://cis188.org/css/style-white.css><!--[if lt IE 9]><script src=https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js></script><script src=https://oss.maxcdn.com/respond/1.4.2/respond.min.js></script><![endif]--><link rel=icon type=image/png href=https://cis188.org/img/favicon.ico></head><body><div class="max-width mx-auto px3 ltr"><div class="content index py4"><header id=header><a href=https://cis188.org/><div id=logo style=background-image:url(https://cis188.org/img/logo.png)></div><div id=title><h1>CIS 188: DevOps</h1></div></a><div id=nav><ul><li class=icon><a href=#><i class="fas fa-bars fa-2x"></i></a></li><li><a href=/>Home</a></li><li><a href=/lectures/>Schedule</a></li><li><a href=/syllabus/>Syllabus</a></li><li><a href=/staff/>Staff</a></li><li><a href=https://www.gradescope.com/courses/229689>Gradescope</a></li><li><a href=https://piazza.com/upenn/spring2021/cis188/home>Piazza</a></li></ul></div></header><style>.main-content{font-family:sans-serif}#header #logo{filter:none;-webkit-filter:none;background-size:contain;border-radius:0}</style><div class=main-content><article class=post itemscope itemtype=http://schema.org/BlogPosting><div class=content itemprop=articleBody><p>Hello world! This is the first lecture.</p><h2 id=demos>Demos</h2><h3 id=poetry>Poetry</h3><p>One reoccurring design pattern we see in DevOps is package managers. This is a tool that helps manage your program&rsquo;s dependencies. In other words, the package manager is in charge of keeping track of what packages your project needs to run correctly, and then downloading those packages in a way that makes it easy for your program to use this auxillary code.</p><p>We&rsquo;ll look at a few different package managers over the course of the semester. Node has one called NPM (Node Package Manager), Java has a package manager called Maven, and Python has a few offerings. Note that these package managers are all a little different because they work with different languages that all have different nuances. This is why we can&rsquo;t reuse package managers across languages.</p><p>The Python package manager we&rsquo;ll be using is called Poetry. Essentially, Poetry allows you to download certain Python libraries, then it creates a virtual python environment on your machine to run your code with the given libraries. So, why the virtual environment? The answer is that Python varies a lot from version to version (especially Python 2 compared to Python 3). The virtual environment ensures that you, your team of developers, and your production environment are all on the same version of Python. This way we can avoid any issues and bugs that may arise from code that&rsquo;s written to work on one version of Python actually being run with a different version of Python.</p><p>Now, let&rsquo;s get into how to actually use Poetry. First, make sure that you have Poetry installed on your machine, instructions for installation can be found <a href=https://python-poetry.org/docs/>here</a>.</p><p>Once you have Poetry installed, let&rsquo;s create a new project:</p><pre><code># Create a new folder called poetry_demo
$ mkdir poetry_demo
# Enter the new folder
$ cd poetry_demo
$ poetry init
</code></pre><p>Now Poetry will give you lots of options for how to initialize your project, just hit enter for all of them (Poetry will use the default setup which is fine for our purposes). Once you&rsquo;ve finished, you&rsquo;ll see that there is a new file <code>pyproject.toml</code> in the directory, this is the file that stores the information we just initialized.</p><p>Next, let&rsquo;s add a dependency:</p><pre><code>$ poetry add numpy
Creating virtualenv poetry-demo-KkU142w6-py3.9 in /Users/airbenderang/Library/Caches/pypoetry/virtualenvs
Using version ^1.19.5 for numpy

Updating dependencies
Resolving dependencies... (39.8s)

Writing lock file

Package operations: 1 install, 0 updates, 0 removals

  â€¢ Installing numpy (1.19.5)
</code></pre><p>Now, Poetry actually does two things here. It downloads NumPy, but before that it actually creates a virtual environment which we are going to use to run our Python code. If we wanted to use a deprecated version of Python (like Python 2) we could configure Poetry to setup the virtual environment so it runs an older release of Python. Again, you will see a new file in your directory, this is the <code>poetry.lock</code> file. It doesn&rsquo;t make much sense to humans, but the <code>poetry.lock</code> file tracks which packages your program depends on and the version number of those packages.</p><p>Finally, let&rsquo;s run some code on Poetry&rsquo;s virtual environment. There are two ways that you will run python programs with Poetry. The first is you can type <code>poetry run script.py</code> and this would run a Python script in the Poetry environment, but instead we will be opening a new shell that will have the Poetry virtual environment as our default Python environment:</p><pre><code>$ poetry shell
Spawning shell within /Users/airbenderang/Library/Caches/pypoetry/virtualenvs/poetry-demo-KkU142w6-py3.9
$ . /Users/airbenderang/Library/Caches/pypoetry/virtualenvs/poetry-demo-KkU142w6-py3.9/bin/activate
# Open a new Python interactive terminal
$ python
Python 3.9.1 (default, Dec 24 2020, 16:53:18) 
[Clang 12.0.0 (clang-1200.0.32.28)] on darwin
Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; x = np.array([1,2],[3,4])
&gt;&gt;&gt; x
array([[1, 2],
       [3, 4]])
&gt;&gt;&gt; y = np.linalg.inv(x)
&gt;&gt;&gt; y
array([[-2. ,  1. ],
       [ 1.5, -0.5]])
&gt;&gt;&gt; exit() # To leave the Python terminal
# Then exit again to leave the Poetry shell
$ exit
</code></pre><p>It looks like NumPy works! This means that Poetry has been properly able to manage our dependencies so that they are accessible when we run our Python code with Poetry. Now, let&rsquo;s make a simple Python file and have Poetry run it. Create a new file called <code>average.py</code> in the same directory as your <code>pyproject.toml</code> and <code>poetry.lock</code> and paste this code into it:</p><pre><code>import sys
import numpy as np

if len(sys.argv) &lt; 2:
    print(&quot;Not enough command line arguments&quot;)
    exit()

xs = []
try:
    for i in range(1, len(sys.argv)):
        xs.append(int(sys.argv[i]))
except:
    print(&quot;Command line arguments are not integers&quot;)
    exit()

print(np.average(np.asarray(xs)))
</code></pre><p>Now, we can run this in the virtual environment created by Poetry:</p><pre><code>$ poetry run python average.py 1 2 3 4
2.5
</code></pre><p>Awesome, it looks like this is working, too. Try changing around the command line arguments!</p></div></article></div><footer id=footer><div class=footer-left>Copyright &copy; 2021 CIS 188: DevOps</div><div class=footer-right><nav><ul><li><a href=/>Home</a></li><li><a href=/lectures/>Schedule</a></li><li><a href=/syllabus/>Syllabus</a></li><li><a href=/staff/>Staff</a></li><li><a href=https://www.gradescope.com/courses/229689>Gradescope</a></li><li><a href=https://piazza.com/upenn/spring2021/cis188/home>Piazza</a></li></ul></nav></div></footer></div></body><link rel=stylesheet href=/lib/font-awesome/css/all.min.css><script src=/lib/jquery/jquery.min.js></script><script src=/js/main.js></script></html>